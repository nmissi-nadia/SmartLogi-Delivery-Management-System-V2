
pipeline {
    // This pipeline is designed to run on an agent that has Docker and Maven available.
    // Using a Docker-based agent is a good practice for reproducibility.
    // For Windows-based Jenkins agents using Docker Desktop, you might need to adjust the Docker socket path.
    agent any // You can specify a label for a specific agent node if needed.

    // Environment variables that are used throughout the pipeline.
    // For production use, sensitive data like tokens and credentials should be stored in and loaded from Jenkins Credentials.
    environment {
        SONAR_HOST_URL      = "http://localhost:9000" // Replace with your SonarQube server URL
        SONAR_PROJECT_KEY   = "SmartLogi-DMS"
        DOCKER_IMAGE_NAME   = "smartlogi-app"
        // Example for loading credentials from Jenkins Credentials store:
        // SONAR_CREDENTIALS_ID = credentials('your-sonar-token-id') 
        // DOCKER_CREDENTIALS_ID = credentials('your-dockerhub-credentials-id')
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out source code..."
                // This will checkout the code from the repository configured in the Jenkins job.
                checkout scm
            }
        }

        stage('Compile') {
            steps {
                echo "Compiling the application..."
                // Execute Maven compile goal. The './' is important for Linux/macOS agents.
                // On Windows, 'mvnw.cmd' is used automatically.
                sh './mvnw compile'
            }
        }

        stage('Unit & Integration Tests') {
            steps {
                echo "Running tests and generating coverage report..."
                // The 'verify' phase runs all tests (unit and integration) and package the application.
                // JaCoCo is expected to be configured in pom.xml to generate the coverage report.
                sh './mvnw verify'
            }
            post {
                always {
                    echo "Archiving test results and coverage reports..."
                    // Archive JUnit test results for display in Jenkins UI.
                    junit 'target/surefire-reports/**/*.xml'
                    // The JaCoCo plugin will use this to display coverage trends.
                    jacoco execPattern: 'target/jacoco.exec'
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                echo "Performing SonarQube analysis..."
                // This step requires the SonarQube Scanner for Jenkins plugin.
                // The SonarQube server ('My-SonarQube') must be configured in 'Manage Jenkins -> Configure System'.
                // The 'withSonarQubeEnv' wrapper injects the server URL and credentials.
                withSonarQubeEnv('My-SonarQube') { // Make sure this matches your SonarQube Server name in Jenkins
                    sh """
                        ./mvnw sonar:sonar \
                          -Dsonar.projectKey=${env.SONAR_PROJECT_KEY}
                    """
                }
            }
        }

        stage('Quality Gate') {
            steps {
                echo "Checking SonarQube Quality Gate status..."
                // This step also requires the SonarQube Scanner for Jenkins plugin.
                // It pauses the pipeline to wait for SonarQube to finish the analysis and then checks the Quality Gate status.
                // 'abortPipeline: true' will fail the pipeline if the Quality Gate conditions are not met.
                timeout(time: 5, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        stage('Build & Tag Docker Image') {
            steps {
                script {
                    echo "Building Docker image..."
                    // We use the Jenkins BUILD_NUMBER to tag the image for versioning.
                    def imageTag = env.BUILD_NUMBER
                    def latestTag = "latest"
                    
                    // Full image name, you might want to add a registry prefix like 'your-registry/'
                    def fullImageName = env.DOCKER_IMAGE_NAME
                    
                    // Build the Docker image using the Dockerfile in the current directory.
                    docker.build(fullImageName + ":${imageTag}", ".")
                    
                    // Tag the new image as 'latest'.
                    docker.image(fullImageName + ":${imageTag}").tag(latestTag)
                }
            }
        }
        
        // This stage is an example of how you would push to a registry.
        // It's conditionally run only for the 'main' branch to avoid pushing feature-branch builds.
        stage('Push Docker Image') {
            when { branch 'main' }
            steps {
                script {
                    echo "Pushing Docker image to registry..."
                    docker.withRegistry('https://index.docker.io/v1/', 'dockerhub-credentials') {
                        docker.image(env.DOCKER_IMAGE_NAME + ":${env.BUILD_NUMBER}").push()
                        docker.image(env.DOCKER_IMAGE_NAME + ":latest").push()
                    }
                }
            }
        }
        
        stage('Deploy') {
            steps {
                echo "Deploying application using Docker Compose..."
                // This uses the CI-specific compose file to start the application.
                // It's assumed that the 'docker-compose-ci.yml' is configured to use the ':latest' tag of your image.
                sh 'docker-compose -f docker-compose-ci.yml up -d'
            }
        }
    }
    
    post {
        // The 'always' block runs regardless of the pipeline's success or failure.
        always {
            echo "Pipeline finished. Cleaning up workspace..."
            // 'cleanWs' is a Jenkins utility to delete the workspace contents.
            // This is good practice to save disk space on the Jenkins agent.
            cleanWs()
        }
        // You can add more specific post-actions for success, failure, etc.
        success {
            echo "Pipeline completed successfully!"
         
        }
        failure {
            echo "Pipeline failed!"
            
        }
    }
}
